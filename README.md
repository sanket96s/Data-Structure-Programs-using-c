<h1>Data structures</h1>

1. **array.c**: This C program enables users to insert, display, and delete elements from an array. It utilizes a menu-driven interface for user interaction, allowing them to perform these operations conveniently. ğŸ’ªğŸ“Š

2. **avl_tree.c**: This code brings you the magic of self-balancing binary search trees, ensuring efficient searching, insertion, and deletion operations. With its elegant algorithms, the AVL tree code is your ticket to a harmonious and well-balanced data structure experience. ğŸŒ³âœ¨

3. **bfs_graph_traversal.c**: This code is your compass for traversing graphs layer by layer. Graph exploration becomes an adventure, unraveling connections and discovering nodes in a systematic and delightful manner. Get ready to traverse graphs like a seasoned explorer! ğŸš€ğŸ”

4. **binary_tree_using_linked_list.c**: This code combines the elegance of linked lists with the hierarchical structure of binary trees. Experience the beauty of node connections and tree traversal in a dynamic and linked fashion. Binary trees have never been this captivating! ğŸŒğŸŒ²

5. **bubble_sort.c**: This classic sorting algorithm comes to life in this code, bubbling up the highest elements to their rightful places. Simple, yet effective, the Bubble Sort code teaches you the art of comparing and swapping elements, making sorting a bubbly affair! ğŸ›ğŸ”„

6. **bucket_sort.c**: This code introduces you to the concept of dividing elements into buckets and sorting each bucket individually, leading to a sorted and organized collection. Explore the simplicity and efficiency of Bucket Sort as you splash into the sorting adventure! ğŸª£ğŸ‰

7. **circular_doubly_linked_list.c**: This code brings you the magic of doubly linked lists that form a circular loop. Traverse through nodes in both directions, experiencing the seamless connection of elements. Circular doubly linked lists redefine the elegance of data organization! ğŸ”„ğŸ”—

8. **circularLinkedList.c**: This C program implements a circular singly linked list with functionalities to create nodes, display the list, add nodes at specified positions, and delete nodes from specified positions. It provides a user-friendly menu-driven interface allowing users to interact with the linked list. The program continues executing until the user chooses to end it. ğŸ”„ğŸ”—

9. **circular_queue.c**: Circular queues offer a seamless way to manage data, and this code is your gateway to mastering the art of enqueueing and dequeueing elements in a circular fashion. Get ready for a revolving experience in data structure manipulation! ğŸ”„ğŸ§‘â€ğŸ¤â€ğŸ§‘

10. **dfs_graph_traversal.c**: This code takes you on a deep dive into graph exploration, unraveling paths and discovering nodes in a recursive and systematic manner. DFS graph traversal becomes an adventure, promising surprises at every turn! ğŸŒğŸš€

11. **doublyLinkedList.c**: This C program implements a doubly linked list with basic operations such as creating nodes, displaying the list, adding nodes at specified positions, and deleting nodes from specified positions. It provides a user-friendly menu-driven interface allowing users to perform these operations on the linked list. ğŸ”—ğŸ”„

12. **hashing_open_addressing.c**: Hashing becomes an exciting journey as elements find their homes using open addressing techniques. This code introduces you to the efficient world of resolving collisions and ensuring a smooth mapping of keys to values. ğŸ—ï¸ğŸ¡

13. **hashing_separate_chaining.c**: This code unveils the magic of managing collisions by creating chains of elements at each hash index. Explore the efficiency and elegance of resolving conflicts and maintaining an organized hash table. Hashing with separate chaining becomes an artful experience! ğŸ§‘â€ğŸ¤â€ğŸ§‘ğŸ”—

14. **implementing_array_as_data_type.c**: This script demonstrates the dynamic implementation of arrays, showcasing their adaptability to store and manipulate various data types. Witness the power of arrays as a fundamental and flexible data structure in the programming landscape! ğŸŒğŸ“š

15. **infix_to_postfix.c**: This code introduces you to the world of converting mathematical expressions, paving the way for efficient evaluation. Experience the elegance of postfix notation as infix expressions gracefully transform, offering a new perspective on expression handling! â¡ï¸ğŸ”„

16. **insertion_sort.c**: This code guides you through the simplicity and effectiveness of sorting elements by gradually building a sorted sequence. Explore the step-by-step process of inserting elements into their correct positions, making sorting a delightful and educational experience! ğŸ§©ğŸ”

17. **linear_binary_search.c**: This code is your guide to the efficient exploration of sorted collections. Whether you're traversing linearly or dividing and conquering with binary search, this script makes finding elements a thrilling and rewarding pursuit! ğŸ”ğŸ¯

18. **singleLinkedList.c**: This C program creates a singly linked list and allows users to add, delete, and display nodes. It offers a simple menu-driven interface for user interaction and terminates upon user request. ğŸ”—ğŸ“

19. **multiple_parenthesis_balancing.c**: This script guides you through the intricacies of maintaining balance, making parenthesis handling a smooth and error-free process! âš–ï¸ğŸ‘¥

20. **postfix_expression_value.c**:  Witness the elegance of postfix notation as this script guides you through the efficient evaluation of mathematical expressions. Explore the step-by-step process of computing values, making postfix expressions a fascinating journey in data manipulation! â¡ï¸ğŸ”¢

21. **queue_using_array.c**: This code is your gateway to mastering the art of enqueuing and dequeuing elements in a structured and organized manner. Explore the first-in-first-out (FIFO) concept and witness how queues efficiently manage data. Get ready for a queue-tastic experience! ğŸ”„ğŸ“¦

22. **queue_using_linked_list.c**: Queues, a fundamental data structure, come to life as elements seamlessly enter

 and exit the queue. This script guides you through the dynamic connections of nodes, making queue operations a smooth and organized experience. Get ready for a queue adventure! ğŸ”—ğŸ”„

23. **selection_sort.c**: This code showcases the step-by-step process of selecting the smallest element and placing it in its sorted position. Explore the beauty of sorting through selection, making every iteration a delightful step towards an ordered sequence! ğŸ¯ğŸ”„

24. **stack_using_array.c**: Stacks, a versatile data structure, find their expression in this script as elements elegantly push and pop. Explore the last-in-first-out (LIFO) concept and witness how stacks efficiently manage data. Get ready for a stack-tacular experience! ğŸ”„ğŸ“š

25. **stack_using_linked_list.c**: This code introduces you to the elegance of managing data in a last-in-first-out (LIFO) fashion. Experience the dynamic connections of nodes as elements seamlessly push and pop, making stack operations a captivating and organized experience! ğŸ”—ğŸ”„
